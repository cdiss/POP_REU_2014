#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#ifdef __SSE2__
#include "xmmintrin.h"
#endif
#ifdef __AVX__
#include "immintrin.h"
#endif
#ifdef __MIC__
#include "immintrin.h"
#endif
#include "WKFUtils.h"
#include "omp.h"
#include <math.h>
#if defined __SSE2__ && !defined  __AVX__
#include "kernelispc_ispc_sse2.h"  // file automatically generated by make
#endif
#ifdef __AVX__
#include "kernelispc_ispc_avx.h"  // file automatically generated by make
#endif

#define UNROLL_FACTOR 8

// this function prototype should be included in the auto-generated include file above.
// Despite the fact that is indeed included there, for some reason the code does not recognize "ispcMandel_inner" unless this prototype is included directly here.
extern "C" {
    extern void ispcMandel_inner(float startReal, float startImag, int32_t steps, int32_t horizsteps, float step, uint32_t * output, uint32_t maxiters);
}

double testCorrect(unsigned *output, int size) {
    double error = 0.0;
    FILE* f = fopen("reference.out", "r");
    if(!f) {printf("Could not open reference.out\n"); return -1.0;}
    for(int i = 0; i < size; i++) {
        int ref;
        fscanf(f, "%i ", &ref);
        error += (double)abs((ref - output[i]))/((double)ref);
    }
    fclose(f);
    return error/((double)size);
}

void genReference(unsigned *output, int size) {
    FILE* f = fopen("reference.out", "w");
    for(int i = 0; i < size; i++) {
        fprintf(f, "%u ", output[i]);
    }
    fclose(f);
}

unsigned* boxFilter(unsigned * output, int size, int horSize) {
    int newSize = size-1;
    int newHorSize = horSize-1;
    int numPix = (newSize)*(newHorSize);
    unsigned * filter = (unsigned*)malloc(numPix*sizeof(unsigned));
#pragma omp parallel for
    for(int i = 0; i < newSize; i++) {
        for(int j = 0; j < newHorSize; j++) {
            unsigned sum = output[i*horSize+j] + output[i*horSize+j+1] 
                            + output[(i+1)*horSize+j] + output[(i+1)*horSize+j+1];
            unsigned average = (sum+2)/4;
            filter[i*newHorSize+j] = average;
        }
    }
    free(output);
    return filter;
}

void serialMandel_double(double startReal, double startImag, int steps, int horizsteps, double step, unsigned* output, unsigned maxIters) {
 
#pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j++) {
            double real = startReal + step*j;
            double imag = startImag - step*i;
            unsigned iters = 0;
            double z_real = 0.0, z_imag = 0.0, z_sum = 0.0;
            while (z_sum < 4.0f && iters < maxIters) {
                iters++;
                double z_real_sq = z_real*z_real;
                double z_imag_sq = z_imag*z_imag;
                z_sum = z_real_sq + z_imag_sq;
                z_imag = 2.0*z_real*z_imag + imag;
                z_real = z_real_sq - z_imag_sq + real;
            }
            output[i*horizsteps+j] = iters;
        }
    }
}

void serialMandel(float startReal, float startImag, int steps, int horizsteps, float step, unsigned* output, unsigned maxIters) {
    
#pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j++) {
            float real = startReal + step*j;
            float imag = startImag - step*i;
            unsigned iters = 0;
            float z_real = 0.0f, z_imag = 0.0f, z_sum = 0.0f;
#if UNROLL_FACTOR > 1
            unsigned iters_old = 0;
            float z_real_old, z_imag_old, z_sum_old;
#endif
            while (z_sum < 4.0f && iters < maxIters) {
#if UNROLL_FACTOR > 1
                iters_old = iters;
                z_real_old = z_real;
                z_imag_old = z_imag;
                z_sum_old = z_sum;
#endif
                
                iters += UNROLL_FACTOR;
                
                float z_real_sq = z_real*z_real;
                float z_imag_sq = z_imag*z_imag;
                z_sum = z_real_sq + z_imag_sq;
                z_imag = 2.0f*z_real*z_imag + imag;
                z_real = z_real_sq - z_imag_sq + real;

#define EXTRA_ITERATION_SERIAL \
z_real_sq = z_real*z_real; \
z_imag_sq = z_imag*z_imag; \
z_sum = z_real_sq + z_imag_sq; \
z_imag = 2.0f*z_real*z_imag + imag; \
z_real = z_real_sq - z_imag_sq + real; 

#if UNROLL_FACTOR >= 2
                EXTRA_ITERATION_SERIAL
#endif

#if UNROLL_FACTOR >= 3
                EXTRA_ITERATION_SERIAL
#endif
                
#if UNROLL_FACTOR >= 4
                EXTRA_ITERATION_SERIAL
#endif
                
#if UNROLL_FACTOR >= 5
                EXTRA_ITERATION_SERIAL
#endif

#if UNROLL_FACTOR >= 6
                EXTRA_ITERATION_SERIAL
#endif

#if UNROLL_FACTOR >= 7
                EXTRA_ITERATION_SERIAL
#endif

#if UNROLL_FACTOR >= 8
                EXTRA_ITERATION_SERIAL
#endif
            } 

#if UNROLL_FACTOR > 1
            iters = iters_old;
            z_real = z_real_old;
            z_imag = z_imag_old;
            z_sum = z_sum_old;
            while (z_sum < 4.0f && iters < maxIters) {
                iters++;
                float z_real_sq = z_real*z_real;
                float z_imag_sq = z_imag*z_imag;
                z_sum = z_real_sq + z_imag_sq;
                z_imag = 2.0f*z_real*z_imag + imag;
                z_real = z_real_sq - z_imag_sq + real;
            }
#endif
            output[i*horizsteps+j] = iters;
        }
    }
}

void intrinsicsMandel(float startReal, float startImag, int steps, int horizsteps, float step, unsigned* output, signed maxiters) {
    
#ifdef __SSE2__
#ifndef __AVX__
// Use SSE2 intrinsics

    /* unsigned integer comparisons not available in SSE2 */

#pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j+=4) {
            __m128 reals = _mm_set1_ps(startReal + step*j);
            __m128 deltas = _mm_set_ps(0.0f, step, 2.0f*step, 3.0f*step);
            reals = _mm_add_ps(reals, deltas);
            __m128 imags = _mm_set1_ps(startImag - step*i);
            __m128i iters = _mm_setzero_si128();
            __m128i maxIters = _mm_set1_epi32(maxiters);
            __m128 z_reals = _mm_setzero_ps();
            __m128 z_imags = _mm_setzero_ps();
            __m128 z_sums = _mm_setzero_ps();
            __m128i cmp_val = _mm_set1_epi32(-1);
            __m128 fours = _mm_set1_ps(4.0f);
            __m128 twos = _mm_set1_ps(2.0f);
            __m128 negativeFours = _mm_set1_ps(-4.0f);
#if UNROLL_FACTOR > 1
            __m128i iters_old = _mm_setzero_si128();
            __m128 z_reals_old, z_imags_old, z_sums_old;
            __m128i cmp_val_old;
            __m128i unroll_factors = _mm_set1_epi32(UNROLL_FACTOR);
#endif
            while ( _mm_movemask_epi8(cmp_val)  &&  !_mm_movemask_epi8(_mm_cmpeq_epi32(iters, maxIters)) ) {
#if UNROLL_FACTOR > 1
                iters_old = iters;
                z_reals_old = z_reals;
                z_imags_old = z_imags;
                z_sums_old = z_sums;
                cmp_val_old = cmp_val;
#endif

#if UNROLL_FACTOR == 1
                /* iters++ */ iters = _mm_sub_epi32(iters, cmp_val);
#else
                /* iters += UNROLL_FACTOR */
                __m128i masked_unroll = _mm_and_si128(unroll_factors, cmp_val);   // mask some entries to 0
                iters = _mm_add_epi32(iters, masked_unroll);
#endif

                __m128 z_real_sq = _mm_mul_ps(z_reals, z_reals);
                __m128 z_imag_sq = _mm_mul_ps(z_imags, z_imags);
                z_sums = _mm_add_ps(z_real_sq, z_imag_sq);
                z_imags = _mm_add_ps(_mm_mul_ps(_mm_mul_ps(twos, z_reals), z_imags), imags);
                z_reals = _mm_add_ps(_mm_sub_ps(z_real_sq, z_imag_sq), reals);
             
#define EXTRA_ITERATION_SSE2 \
z_real_sq = _mm_mul_ps(z_reals, z_reals); \
z_imag_sq = _mm_mul_ps(z_imags, z_imags); \
z_sums = _mm_add_ps(z_real_sq, z_imag_sq); \
z_imags = _mm_add_ps(_mm_mul_ps(_mm_mul_ps(twos, z_reals), z_imags), imags); \
z_reals = _mm_add_ps(_mm_sub_ps(z_real_sq, z_imag_sq), reals);

#if UNROLL_FACTOR >= 2
                EXTRA_ITERATION_SSE2
#endif

#if UNROLL_FACTOR >= 3
                EXTRA_ITERATION_SSE2
#endif

#if UNROLL_FACTOR >= 4
                EXTRA_ITERATION_SSE2
#endif

#if UNROLL_FACTOR >= 5
                EXTRA_ITERATION_SSE2
#endif

#if UNROLL_FACTOR >= 6
                EXTRA_ITERATION_SSE2
#endif

#if UNROLL_FACTOR >= 7
                EXTRA_ITERATION_SSE2
#endif

#if UNROLL_FACTOR >= 8
                EXTRA_ITERATION_SSE2
#endif

                __m128i isLessThan4 = _mm_castps_si128(_mm_cmplt_ps(z_sums, fours));
                __m128i isGtrThanNeg4 = _mm_castps_si128(_mm_cmpgt_ps(z_sums, negativeFours));
                cmp_val = _mm_and_si128(isLessThan4, isGtrThanNeg4);
            }

#if UNROLL_FACTOR > 1
            iters = iters_old;
            z_reals = z_reals_old;
            z_imags = z_imags_old;
            z_sums = z_sums_old;
            cmp_val = cmp_val_old;
            while ( _mm_movemask_epi8(cmp_val) && !_mm_movemask_epi8(_mm_cmpeq_epi32(iters, maxIters)) ) {
                /* iters++ */ iters = _mm_sub_epi32(iters, cmp_val);
                __m128 z_real_sq = _mm_mul_ps(z_reals, z_reals);
                __m128 z_imag_sq = _mm_mul_ps(z_imags, z_imags);
                z_sums = _mm_add_ps(z_real_sq, z_imag_sq);
                z_imags = _mm_add_ps(_mm_mul_ps(_mm_mul_ps(twos, z_reals), z_imags), imags);
                z_reals = _mm_add_ps(_mm_sub_ps(z_real_sq, z_imag_sq), reals);
               
                __m128i isLessThan4 = _mm_castps_si128(_mm_cmplt_ps(z_sums, fours));
                __m128i isGtrThanNeg4 = _mm_castps_si128(_mm_cmpgt_ps(z_sums, negativeFours));
                cmp_val = _mm_and_si128(isLessThan4, isGtrThanNeg4);
            }
            #endif

            int startIndex = i*horizsteps+j;    
            output[startIndex++] = ((unsigned*)(&iters))[3];
            output[startIndex++] = ((unsigned*)(&iters))[2];
            output[startIndex++] = ((unsigned*)(&iters))[1];
            output[startIndex++] = ((unsigned*)(&iters))[0]; 
        }
    }

#else
// Use AVX intrinsics

    float maxitersfloat = (float)maxiters;
#pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j+=8) {
            __m256 reals = _mm256_set1_ps(startReal + step*j);
            __m256 deltas = _mm256_set_ps(0.0f, step, 2.0f*step, 3.0f*step, 4.0f*step, 5.0f*step, 6.0f*step, 7.0f*step);
            reals = _mm256_add_ps(reals, deltas);
            __m256 imags = _mm256_set1_ps(startImag - step*i);
            __m256i iters = _mm256_setzero_si256();
            __m256 maxIters = _mm256_set1_ps(maxitersfloat);
            __m256 z_reals = _mm256_setzero_ps();
            __m256 z_imags = _mm256_setzero_ps();
            __m256 z_sums = _mm256_setzero_ps();
            __m256i cmp_val = _mm256_set1_epi32(-1);
            __m256 fours = _mm256_set1_ps(4.0f);
            __m256 twos = _mm256_set1_ps(2.0f);
            __m256 negativeFours = _mm256_set1_ps(-4.0f);
#if UNROLL_FACTOR > 1
            __m256i iters_old = _mm256_setzero_si256();
            __m256 z_reals_old, z_imags_old, z_sums_old;
            __m256i cmp_val_old;
            __m256i unroll_factors = _mm256_set1_epi32(UNROLL_FACTOR);
#endif
            while ( _mm256_movemask_ps(_mm256_castsi256_ps(cmp_val)) && !_mm256_movemask_ps(_mm256_cmp_ps(_mm256_cvtepi32_ps(iters), maxIters, _CMP_GE_OQ)) ) { 
#if UNROLL_FACTOR > 1
                iters_old = iters;
                z_reals_old = z_reals;
                z_imags_old = z_imags;
                z_sums_old = z_sums;
                cmp_val_old = cmp_val;
#endif
                
                // incrementing iters performed by using integer ops separately on the halves of iters
                __m128i itershalf0 = _mm256_extractf128_si256(iters, 0);  // half of iters
                __m128i itershalf1 = _mm256_extractf128_si256(iters, 1);  // other half
                
#if UNROLL_FACTOR == 1
                // iters++
                __m128i cmpvalhalf0 = _mm256_extractf128_si256(cmp_val, 0);
                __m128i cmpvalhalf1 = _mm256_extractf128_si256(cmp_val, 1);
                itershalf0 = _mm_sub_epi32(itershalf0, cmpvalhalf0);
                itershalf1 = _mm_sub_epi32(itershalf1, cmpvalhalf1);
#else
                // iters += UNROLL_FACTOR
                __m256i masked_unroll = _mm256_castps_si256(_mm256_and_ps(_mm256_castsi256_ps(unroll_factors), _mm256_castsi256_ps(cmp_val)));
                __m128i maskedunrollhalf0 = _mm256_extractf128_si256(masked_unroll, 0);
                __m128i maskedunrollhalf1 = _mm256_extractf128_si256(masked_unroll, 1);
                itershalf0 = _mm_add_epi32(itershalf0, maskedunrollhalf0);
                itershalf1 = _mm_add_epi32(itershalf1, maskedunrollhalf1);
#endif

                // reassemble iters
                iters = _mm256_insertf128_si256(iters, itershalf0, 0);
                iters = _mm256_insertf128_si256(iters, itershalf1, 1);    
                
                __m256 z_real_sq = _mm256_mul_ps(z_reals, z_reals);
                __m256 z_imag_sq = _mm256_mul_ps(z_imags, z_imags);
                z_sums = _mm256_add_ps(z_real_sq, z_imag_sq);
                z_imags = _mm256_add_ps(_mm256_mul_ps(_mm256_mul_ps(twos, z_reals), z_imags), imags); \
                z_reals = _mm256_add_ps(_mm256_sub_ps(z_real_sq, z_imag_sq), reals);

#define EXTRA_ITERATION_AVX \
z_real_sq = _mm256_mul_ps(z_reals, z_reals); \
z_imag_sq = _mm256_mul_ps(z_imags, z_imags); \
z_sums = _mm256_add_ps(z_real_sq, z_imag_sq); \
z_imags = _mm256_add_ps(_mm256_mul_ps(_mm256_mul_ps(twos, z_reals), z_imags), imags); \
z_reals = _mm256_add_ps(_mm256_sub_ps(z_real_sq, z_imag_sq), reals);

#if UNROLL_FACTOR >= 2
                EXTRA_ITERATION_AVX
#endif
                
#if UNROLL_FACTOR >= 3
                EXTRA_ITERATION_AVX
#endif
                
#if UNROLL_FACTOR >= 4
                EXTRA_ITERATION_AVX
#endif
                
#if UNROLL_FACTOR >= 5
                EXTRA_ITERATION_AVX
#endif
                
#if UNROLL_FACTOR >= 6
                EXTRA_ITERATION_AVX
#endif
                
#if UNROLL_FACTOR >= 7
                EXTRA_ITERATION_AVX
#endif
                
#if UNROLL_FACTOR >= 8
                EXTRA_ITERATION_AVX
#endif
                
                __m256 isLessThan4 = _mm256_cmp_ps(z_sums, fours, _CMP_LT_OQ);
                __m256 isGtrThanNeg4 = _mm256_cmp_ps(z_sums, negativeFours, _CMP_GT_OQ);
                cmp_val = _mm256_castps_si256(_mm256_and_ps(isLessThan4, isGtrThanNeg4));
            }

#if UNROLL_FACTOR > 1
            iters = iters_old;
            z_reals = z_reals_old;
            z_imags = z_imags_old;
            z_sums = z_sums_old;
            cmp_val = cmp_val_old;
            while ( _mm256_movemask_ps(_mm256_castsi256_ps(cmp_val)) && !_mm256_movemask_ps(_mm256_cmp_ps(_mm256_cvtepi32_ps(iters), maxIters, _CMP_GE_OQ)) ) { 
                __m128i itershalf0 = _mm256_extractf128_si256(iters, 0);  // half of iters
                __m128i itershalf1 = _mm256_extractf128_si256(iters, 1);  // other half
                // iters++
                __m128i cmpvalhalf0 = _mm256_extractf128_si256(cmp_val, 0);
                __m128i cmpvalhalf1 = _mm256_extractf128_si256(cmp_val, 1);
                itershalf0 = _mm_sub_epi32(itershalf0, cmpvalhalf0);
                itershalf1 = _mm_sub_epi32(itershalf1, cmpvalhalf1);
                // reassemble iters
                iters = _mm256_insertf128_si256(iters, itershalf0, 0);
                iters = _mm256_insertf128_si256(iters, itershalf1, 1);    
                
                __m256 z_real_sq = _mm256_mul_ps(z_reals, z_reals);
                __m256 z_imag_sq = _mm256_mul_ps(z_imags, z_imags);
                z_sums = _mm256_add_ps(z_real_sq, z_imag_sq);
                z_imags = _mm256_add_ps(_mm256_mul_ps(_mm256_mul_ps(twos, z_reals), z_imags), imags); \
                z_reals = _mm256_add_ps(_mm256_sub_ps(z_real_sq, z_imag_sq), reals);

                __m256 isLessThan4 = _mm256_cmp_ps(z_sums, fours, _CMP_LT_OQ);
                __m256 isGtrThanNeg4 = _mm256_cmp_ps(z_sums, negativeFours, _CMP_GT_OQ);
                cmp_val = _mm256_castps_si256(_mm256_and_ps(isLessThan4, isGtrThanNeg4));
            }
#endif
            
            int startIndex = i*horizsteps+j;    
            output[startIndex++] = ((unsigned*)(&iters))[7];
            output[startIndex++] = ((unsigned*)(&iters))[6];
            output[startIndex++] = ((unsigned*)(&iters))[5];
            output[startIndex++] = ((unsigned*)(&iters))[4];
            output[startIndex++] = ((unsigned*)(&iters))[3];
            output[startIndex++] = ((unsigned*)(&iters))[2];
            output[startIndex++] = ((unsigned*)(&iters))[1];
            output[startIndex++] = ((unsigned*)(&iters))[0]; 
        }
    }

#endif
#else  // #ifndef __SSE2__
#ifdef __MIC__
// Use Phi intrinsics

#pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j+=16) {
            __m512 reals = _mm512_set1_ps(startReal + step*j);
            __m512 deltas = _mm512_set_ps(0.0f, step, 2.0f*step, 3.0f*step, 4.0f*step, 5.0f*step, 6.0f*step, 7.0f*step, 8.0f*step, 9.0f*step, 10.0f*step, 11.0f*step, 12.0f*step, 13.0f*step, 14.0f*step, 15.0f*step);
            reals = _mm512_add_ps(reals, deltas);
            __m512 imags = _mm512_set1_ps(startImag - step*i);
            __m512i iters = _mm512_setzero_epi32();
            __m512i maxIters = _mm512_set1_epi32(maxiters);
            __m512 z_reals = _mm512_setzero_ps();
            __m512 z_imags = _mm512_setzero_ps();
            __m512 z_sums = _mm512_setzero_ps();
            __mmask16 cmp_val = _mm512_int2mask(-1);
            __m512 fours = _mm512_set1_ps(4.0f);
            __m512 twos = _mm512_set1_ps(2.0f);
            __m512i ones = _mm512_set1_epi32(1);
            __m512i unroll_factors = _mm512_set1_epi32(UNROLL_FACTOR);
#if UNROLL_FACTOR > 1
            __m512i iters_old = _mm512_setzero_epi32();
            __m512 z_reals_old, z_imags_old, z_sums_old;
#endif
            while ( (cmp_val)  &&  !(_mm512_cmpeq_epi32_mask(iters, maxIters)) ) {
#if UNROLL_FACTOR > 1
                iters_old = iters;
                z_reals_old = z_reals;
                z_imags_old = z_imags;
                z_sums_old = z_sums;
#endif
                
                /* iters += UNROLL_FACTOR */ 
                // Since masking is free on Phi, we can go without the #if we used for SSE2 and AVX here
                iters = _mm512_mask_add_epi32(iters, cmp_val, iters, unroll_factors);

                __m512 z_real_sq = _mm512_mul_ps(z_reals, z_reals);
                __m512 z_imag_sq = _mm512_mul_ps(z_imags, z_imags);
                z_sums = _mm512_mask_add_ps(z_sums, cmp_val, z_real_sq, z_imag_sq);
                z_imags = _mm512_fmadd_ps(_mm512_mul_ps(twos, z_reals), z_imags, imags);
                z_reals = _mm512_add_ps(_mm512_sub_ps(z_real_sq, z_imag_sq), reals);
               
#define EXTRA_ITERATION_MIC \
z_real_sq = _mm512_mul_ps(z_reals, z_reals); \
z_imag_sq = _mm512_mul_ps(z_imags, z_imags); \
z_sums = _mm512_mask_add_ps(z_sums, cmp_val, z_real_sq, z_imag_sq); \
z_imags = _mm512_fmadd_ps(_mm512_mul_ps(twos, z_reals), z_imags, imags); \
z_reals = _mm512_add_ps(_mm512_sub_ps(z_real_sq, z_imag_sq), reals);

#if UNROLL_FACTOR >= 2
                EXTRA_ITERATION_MIC
#endif

#if UNROLL_FACTOR >= 3
                EXTRA_ITERATION_MIC
#endif

#if UNROLL_FACTOR >= 4
                EXTRA_ITERATION_MIC
#endif

#if UNROLL_FACTOR >= 5
                EXTRA_ITERATION_MIC
#endif

#if UNROLL_FACTOR >= 6
                EXTRA_ITERATION_MIC
#endif

#if UNROLL_FACTOR >= 7
                EXTRA_ITERATION_MIC
#endif

#if UNROLL_FACTOR >= 8
                EXTRA_ITERATION_MIC
#endif

                // Option 1
                // __mmask16 isLessThan4 = _mm512_cmplt_ps_mask(z_sums, fours);
                // nle: not less than or equal (i.e. greater than)
                // __mmask16 isGtrThanNeg4 = _mm512_cmpnle_ps_mask(z_sums, negativeFours); 
                // cmp_val = _mm512_kand(isLessThan4, isGtrThanNeg4);
                
                // Option 2
                // Only the <4 comparison is needed because we are doing masked adds to z_sums 
                // (in Phi architecture masked add is same cost as add)
                cmp_val = _mm512_cmplt_ps_mask(z_sums, fours);
               
            }

#if UNROLL_FACTOR > 1
            iters = iters_old;
            z_reals = z_reals_old;
            z_imags = z_imags_old;
            z_sums = z_sums_old;
            while ( (cmp_val)  &&  !(_mm512_cmpeq_epi32_mask(iters, maxIters)) ) {
                /* iters++ */ iters = _mm512_mask_add_epi32(iters, cmp_val, iters, ones);
                __m512 z_real_sq = _mm512_mul_ps(z_reals, z_reals);
                __m512 z_imag_sq = _mm512_mul_ps(z_imags, z_imags);
                z_sums = _mm512_mask_add_ps(z_sums, cmp_val, z_real_sq, z_imag_sq);
                z_imags = _mm512_fmadd_ps(_mm512_mul_ps(twos, z_reals), z_imags, imags);
                z_reals = _mm512_add_ps(_mm512_sub_ps(z_real_sq, z_imag_sq), reals);
                cmp_val = _mm512_cmplt_ps_mask(z_sums, fours);
            }
#endif

            int index = i*horizsteps+j;    
            output[index++] = ((unsigned*)(&iters))[15];
            output[index++] = ((unsigned*)(&iters))[14];
            output[index++] = ((unsigned*)(&iters))[13];
            output[index++] = ((unsigned*)(&iters))[12];
            output[index++] = ((unsigned*)(&iters))[11];
            output[index++] = ((unsigned*)(&iters))[10];
            output[index++] = ((unsigned*)(&iters))[9];
            output[index++] = ((unsigned*)(&iters))[8];
            output[index++] = ((unsigned*)(&iters))[7];
            output[index++] = ((unsigned*)(&iters))[6];
            output[index++] = ((unsigned*)(&iters))[5];
            output[index++] = ((unsigned*)(&iters))[4];
            output[index++] = ((unsigned*)(&iters))[3];
            output[index++] = ((unsigned*)(&iters))[2];
            output[index++] = ((unsigned*)(&iters))[1];
            output[index++] = ((unsigned*)(&iters))[0];
        }
    }

#endif   // #ifdef __MIC__
#endif   // #ifdef __SSE2__

}  // end function intrinsicsMandel

void intelMandel(float startReal, float startImag, int steps, int horizsteps, float step, unsigned * output, unsigned maxiters) {
#ifdef __SSE2__
#ifndef __AVX__
/* SSE2 */
#define VECTOR_WIDTH 4
#else  // #ifdef __AVX__
/* AVX */
#define VECTOR_WIDTH 8
#endif
#else  // #ifndef __SSE2__
#ifdef __MIC__
#define VECTOR_WIDTH 16
#endif // __MIC__
#endif // __SSE2__


#define INITIALIZE(type, varname, value) \
    type varname[VECTOR_WIDTH]; \
    for (int index = 0; index < VECTOR_WIDTH; index++ ) \
        varname[index] = value;

#pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j += VECTOR_WIDTH) {
            INITIALIZE(float, real, startReal + step*(j+index))
            const float imagcoord = startImag - step*i;   // the value for all lanes of the vector
            INITIALIZE(float, imag, imagcoord)
            INITIALIZE(unsigned, iters, 0)
            INITIALIZE(float, z_real, 0.0f)
            INITIALIZE(float, z_imag, 0.0f)
            INITIALIZE(bool, on, true)
            bool any_on = true;
#if UNROLL_FACTOR > 1
            INITIALIZE(float, iters_old, 0)
            float z_real_old[VECTOR_WIDTH], z_imag_old[VECTOR_WIDTH], z_sum_old[VECTOR_WIDTH];
            bool on_old[VECTOR_WIDTH];
#endif
            while (any_on) {
                any_on = false;
#pragma vector always    // tell Intel compiler to vectorize even if it seems inefficient
                for (int index = 0; index < VECTOR_WIDTH; index++) {
                    if (on[index]) {
#if UNROLL_FACTOR > 1
                        iters_old[index] = iters[index];
                        z_real_old[index] = z_real[index];
                        z_imag_old[index] = z_imag[index];
                        on_old[index] = true;
#endif

                        iters[index] += UNROLL_FACTOR;
                        
                        float z_real_sq = z_real[index]*z_real[index];
                        float z_imag_sq = z_imag[index]*z_imag[index];
                        float z_sum = z_real_sq + z_imag_sq;
                        z_imag[index] = 2.0f*z_real[index]*z_imag[index] + imag[index];
                        z_real[index] = z_real_sq - z_imag_sq + real[index];
                        
#define EXTRA_ITERATION_INTEL \
z_real_sq = z_real[index]*z_real[index]; \
z_imag_sq = z_imag[index]*z_imag[index]; \
z_sum = z_real_sq + z_imag_sq; \
z_imag[index] = 2.0f*z_real[index]*z_imag[index] + imag[index]; \
z_real[index] = z_real_sq - z_imag_sq + real[index];

#if UNROLL_FACTOR >= 2
                        EXTRA_ITERATION_INTEL
#endif

#if UNROLL_FACTOR >= 3
                        EXTRA_ITERATION_INTEL
#endif

#if UNROLL_FACTOR >= 4
                        EXTRA_ITERATION_INTEL
#endif

#if UNROLL_FACTOR >= 5
                        EXTRA_ITERATION_INTEL
#endif

#if UNROLL_FACTOR >= 6
                        EXTRA_ITERATION_INTEL
#endif

#if UNROLL_FACTOR >= 7
                        EXTRA_ITERATION_INTEL
#endif

#if UNROLL_FACTOR >= 8
                        EXTRA_ITERATION_INTEL
#endif
                        if (z_sum < 4.0f && iters[index] < maxiters)
                           any_on = true;
                        else 
                           on[index] = false;
                    } else {   // was not on[index]
                        on_old[index] = false;
                    }
                }
            }
            
#if UNROLL_FACTOR > 1
            for (int index = 0; index < VECTOR_WIDTH; index++) {
                iters[index] = iters_old[index];
                z_real[index] = z_real_old[index];
                z_imag[index] = z_imag_old[index];
                on[index] = on_old[index];
            }
            any_on = true;
            while (any_on) {
                any_on = false;
#pragma vector always    // tell Intel compiler to vectorize even if it seems inefficient
                for (int index = 0; index < VECTOR_WIDTH; index++) {
                    if (on[index]) {
                        iters[index]++;
                        float z_real_sq = z_real[index]*z_real[index];
                        float z_imag_sq = z_imag[index]*z_imag[index];
                        float z_sum = z_real_sq + z_imag_sq;
                        z_imag[index] = 2.0f*z_real[index]*z_imag[index] + imag[index];
                        z_real[index] = z_real_sq - z_imag_sq + real[index];
                        if (z_sum < 4.0f && iters[index] < maxiters)
                           any_on = true;
                        else 
                           on[index] = false;
                    }
                }
            } 
#endif

            for (int index = 0; index < VECTOR_WIDTH; index++)
                output[i*horizsteps+j+index] = iters[index];
        }
    }
}

void ompMandel(float startReal, float startImag, int steps, int horizsteps, float step, unsigned * output, unsigned maxiters) {
#ifdef __SSE2__
#ifndef __AVX__
/* SSE2 */
#define VECTOR_WIDTH 4
#else  // #ifdef __AVX__
/* AVX */
#define VECTOR_WIDTH 8
#endif
#else  // #ifndef __SSE2__
#ifdef __MIC__
#define VECTOR_WIDTH 16
#endif // __MIC__
#endif // __SSE2__


#define INITIALIZE(type, varname, value) \
    type varname[VECTOR_WIDTH]; \
    for (int index = 0; index < VECTOR_WIDTH; index++ ) \
        varname[index] = value;

#pragma omp parallel for simd schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j += VECTOR_WIDTH) {
            INITIALIZE(float, real, startReal + step*(j+index))
            const float imagcoord = startImag - step*i;   // the value for all lanes of the vector
            INITIALIZE(float, imag, imagcoord)
            INITIALIZE(unsigned, iters, 0)
            INITIALIZE(float, z_real, 0.0f)
            INITIALIZE(float, z_imag, 0.0f)
            INITIALIZE(bool, on, true)
            bool any_on = true;
#if UNROLL_FACTOR > 1
            INITIALIZE(float, iters_old, 0)
            float z_real_old[VECTOR_WIDTH], z_imag_old[VECTOR_WIDTH], z_sum_old[VECTOR_WIDTH];
            bool on_old[VECTOR_WIDTH];
#endif
            while (any_on) {
                any_on = false;
                for (int index = 0; index < VECTOR_WIDTH; index++) {
                    if (on[index]) {
#if UNROLL_FACTOR > 1
                        iters_old[index] = iters[index];
                        z_real_old[index] = z_real[index];
                        z_imag_old[index] = z_imag[index];
                        on_old[index] = true;
#endif

                        iters[index] += UNROLL_FACTOR;
                        
                        float z_real_sq = z_real[index]*z_real[index];
                        float z_imag_sq = z_imag[index]*z_imag[index];
                        float z_sum = z_real_sq + z_imag_sq;
                        z_imag[index] = 2.0f*z_real[index]*z_imag[index] + imag[index];
                        z_real[index] = z_real_sq - z_imag_sq + real[index];
                        
#define EXTRA_ITERATION_OMP \
z_real_sq = z_real[index]*z_real[index]; \
z_imag_sq = z_imag[index]*z_imag[index]; \
z_sum = z_real_sq + z_imag_sq; \
z_imag[index] = 2.0f*z_real[index]*z_imag[index] + imag[index]; \
z_real[index] = z_real_sq - z_imag_sq + real[index];

#if UNROLL_FACTOR >= 2
                        EXTRA_ITERATION_OMP
#endif

#if UNROLL_FACTOR >= 3
                        EXTRA_ITERATION_OMP
#endif

#if UNROLL_FACTOR >= 4
                        EXTRA_ITERATION_OMP
#endif

#if UNROLL_FACTOR >= 5
                        EXTRA_ITERATION_OMP
#endif

#if UNROLL_FACTOR >= 6
                        EXTRA_ITERATION_OMP
#endif

#if UNROLL_FACTOR >= 7
                        EXTRA_ITERATION_OMP
#endif

#if UNROLL_FACTOR >= 8
                        EXTRA_ITERATION_OMP
#endif
                        if (z_sum < 4.0f && iters[index] < maxiters)
                           any_on = true;
                        else 
                           on[index] = false;
                    } else {   // was not on[index]
                        on_old[index] = false;
                    }
                }
            }
            
#if UNROLL_FACTOR > 1
            for (int index = 0; index < VECTOR_WIDTH; index++) {
                iters[index] = iters_old[index];
                z_real[index] = z_real_old[index];
                z_imag[index] = z_imag_old[index];
                on[index] = on_old[index];
            }
            any_on = true;
            while (any_on) {
                any_on = false;
                for (int index = 0; index < VECTOR_WIDTH; index++) {
                    if (on[index]) {
                        iters[index]++;
                        float z_real_sq = z_real[index]*z_real[index];
                        float z_imag_sq = z_imag[index]*z_imag[index];
                        float z_sum = z_real_sq + z_imag_sq;
                        z_imag[index] = 2.0f*z_real[index]*z_imag[index] + imag[index];
                        z_real[index] = z_real_sq - z_imag_sq + real[index];
                        if (z_sum < 4.0f && iters[index] < maxiters)
                           any_on = true;
                        else 
                           on[index] = false;
                    }
                }
            } 
#endif

            for (int index = 0; index < VECTOR_WIDTH; index++)
                output[i*horizsteps+j+index] = iters[index];
        }
    }
}

void ispcMandel(float startReal, float startImag, int steps, int horizsteps, float step, unsigned * output, unsigned maxiters) {
#pragma omp parallel for schedule(dynamic)
    for(int i = 0; i < steps; i++) {
        ispcMandel_inner(startReal, startImag, i, horizsteps, step, output, maxiters);
    }
}

void printUsage() {
    printf("Usage: testHarness serial|intrin|intel|omp|ISPC -c centerReal centerImag -s size -d steps -f filename -b\n");
}

int main(int argc, char* argv[]) {
    float centerReal = 0.0f, centerImag = 0.0f;
    float size = 4.0f;
    int steps = 864;
    char filename[50] = "mandelbrot.ppm";
    unsigned maxIters = 20050;
    bool bench = false;

    // change to true, compile & run to create reference.out
    bool initRefData = false;

    if (argc < 2) {
      printUsage();
      return 0;
    }

    // parse serial|intrin|intel|omp|ISPC
    bool serial = false;
    bool intrin = false;
    bool intel = false;
    bool omp = false;
    bool ispc = false;
    if (!strcmp(argv[1], "serial\0")) serial = true;
    else if (!strcmp(argv[1], "intrin\0")) intrin = true;
    else if (!strcmp(argv[1], "intel\0")) intel = true;
    else if (!strcmp(argv[1], "omp\0")) omp = true;
    else if (!strcmp(argv[1], "ISPC\0")) ispc = true;
    else {
      printUsage();
      return 0;
    }

    // parse all other command line args
    int counter = 2;
    while ( counter < argc ) {
        if (!strcmp(argv[counter], "-c\0") && argc >= (counter + 3)) {
            sscanf(argv[++counter], "%f", &centerReal);
            sscanf(argv[++counter], "%f", &centerImag);
            counter++;
        } else if (!strcmp(argv[counter], "-s\0") && argc >= (counter + 2)) {
            sscanf(argv[++counter], "%f", &size);
            counter++;
        } else if (!strcmp(argv[counter], "-d\0") && argc >= (counter + 2)) {
            sscanf(argv[++counter], "%i", &steps);
            counter++;
        } else if (!strcmp(argv[counter], "-f\0") && argc >= (counter + 2)) {
            sscanf(argv[++counter], "%s", filename);
            counter++;
        } else if (!strcmp(argv[counter], "-b\0")) {
            bench = true;
            counter++;
        } else {
            printUsage();
            return 0;
        }
    }

    // Standardized benchmarking test parameters
    if(bench) {
        centerReal = -0.54f;
        centerImag = 0.5f;
        size = 0.1f;
        steps = 864;
        maxIters = 50000;
    }

    if (intrin || intel)
#ifdef __SSE2__
#ifndef __AVX__
        // make steps divisible by 4
        while (steps % 4 != 0) steps++;
#else // #ifdef __AVX__
        // make steps divisible by 8
        while (steps % 8 != 0) steps++;
#endif
#else // #ifndef __SSE2__
#ifdef __MIC__
        // make steps divisible by 16
        while (steps % 16 != 0) steps++;
#endif // __MIC__
#endif // __SSE2__

    int horizsteps = steps*16/9;
    if (horizsteps % 16 != 0) {
        printf("Use one of these numbers of steps: 576, 864, 1152, 1440, 1728, 2304\n");
        printf("steps: %i, horizsteps: %i\n", steps, horizsteps);
        return 0;
    }

    int numPixels = steps*horizsteps;
    unsigned* output = (unsigned*)malloc(numPixels*sizeof(unsigned));
    float horizsize = size*16.0f/9.0f;
    float startReal = centerReal - (horizsize/2.0f), startImag = centerImag + (size/2.0f);
    float stepsize = size/steps;
    float time;
    
    if(initRefData) {
        maxIters = 50000;
        serialMandel(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        output = boxFilter(output, steps, horizsteps);
        numPixels = (steps-1)*(horizsteps-1);
        genReference(output, numPixels);
        printf("At 5%% tolerance, the percent error was  %.3f%%.\n", 100.0*testCorrect(output, numPixels)); 
        return 0;
    }

    if (bench) {
        int warmUpRuns = 10;
        for (int i = 0; i < warmUpRuns; i++) {
            serialMandel(-2.0f, 2.0f, steps, horizsteps, 0.004f, output, 500);
        }
        printf("======================\n");
    }

    // MAIN TEST RUN
    wkf_timerhandle timer = wkf_timer_create();
    wkf_timer_start(timer); 
    if (serial) serialMandel(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
    if (intrin) intrinsicsMandel(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
    if (intel) intelMandel(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
    if (omp) ompMandel(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
    if (ispc) ispcMandel(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
    wkf_timer_stop(timer);
    time = wkf_timer_time(timer);
    if(bench) printf("Time: %f\n", time);

    // box filter algorithm
    output = boxFilter(output, steps--, horizsteps--);
    int oldNumPixels = numPixels;
    numPixels = steps*horizsteps;

    // performance metrics
    if (bench) {
        uint64_t sum = 0;
#pragma omp parallel for reduction(+:sum)
        for (int i = 0; i < numPixels; i++) {
            unsigned iters = output[i];
            sum += iters;
        }
        printf("Iters per second: %f\nIters per pixel per second: %f\n", sum/time, (sum/oldNumPixels)/time);
    } 

    // correctness test
    if (bench) {
        double error = testCorrect(output, numPixels);
        if (error < 0) { printf("Aborting.\n"); return 0; }  // testCorrect failed to find the reference file
        printf("The percent error was %.3f%%. ", 100.0*error);
        if(error < 0.05) {
            printf("Error within acceptable region.\n");
        } else {
            printf("Error outside acceptable region. Aborting.\n");
            return 0;
        }
        printf("======================\n");
    }

#define ITERS_CYCLE 100
#define COLORMIN 0
#define COLORMAX 220

    // write picture data
    FILE* f = fopen(filename, "w");
    if (!f) { printf("Error opening file\n"); return(0); }
    fprintf(f, "P6\n%i %i\n255\n", horizsteps, steps);    
    unsigned char* buffer = (unsigned char*)malloc(3*numPixels*sizeof(unsigned char));
#pragma omp parallel for 
    for (int i = 0; i < numPixels; i++) {
        int itersForColor = (maxIters-output[i]) % (ITERS_CYCLE*4);
        char red, green, blue;
        switch(itersForColor/ITERS_CYCLE) {
            case 0: // black to green region
                red = COLORMIN;
                green = COLORMIN + (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                blue = COLORMIN;
                break;               
            case 1: // green to red region
                itersForColor -= ITERS_CYCLE;
                red = COLORMIN + (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                green = COLORMAX - (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                blue = COLORMIN;
                break;
            case 2: // red to blue region
                itersForColor -= (2*ITERS_CYCLE);
                red = COLORMAX - (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                green = COLORMIN;
                blue = COLORMIN + (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                break;
            case 3: // blue to black region
                itersForColor -= (3*ITERS_CYCLE);
                red = COLORMIN; 
                green = COLORMIN;
                blue = COLORMAX - (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                break;
            default: // should never happen
                printf("Error in color mapping\n");
                break;
        }
        int bufferIndex = i*3;
        buffer[bufferIndex++] = red;
        buffer[bufferIndex++] = green;
        buffer[bufferIndex] = blue;
    }
     
    fwrite(buffer, sizeof(unsigned char), 3*numPixels, f);

    fclose(f);

    return 0;
}

