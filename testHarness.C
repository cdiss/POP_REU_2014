#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#ifdef __SSE2__
#include "xmmintrin.h"
#endif
#ifdef __AVX__
#include "immintrin.h"
#endif
#ifdef __MIC__
#include "immintrin.h"
#endif
#include "WKFUtils.h"
#include "intrinsicsUtils.C"
#include "omp.h"
#include <math.h>
#if defined __SSE2__ && !defined  __AVX__
#include "kernelispc_ispc_sse2.h"  // file automatically generated by make
#endif
#ifdef __AVX__
#include "kernelispc_ispc_avx.h"  // file automatically generated by make
#endif

// this function prototype should be included in the auto-generated include file above.
// Despite the fact that is indeed included there, for some reason the code does not recognize "ispcFloat" unless this prototype is included directly here.
extern "C" {
    extern void ispcFloat(float startReal, float startImag, int32_t steps, int32_t horizsteps, float step, uint32_t * output, uint32_t maxiters);
}

extern "C" {
    extern void ispcFloatOMP(float startReal, float startImag, int32_t i, int32_t horizsteps, float step, uint32_t * output, uint32_t maxiters);
}

void ispcOMP(float startReal, float startImag, int steps, int horizsteps, float step, unsigned * output, unsigned maxiters) {
    #pragma omp parallel for schedule(dynamic)
    for(int i = 0; i < steps; i++) {
        ispcFloatOMP(startReal, startImag, i, horizsteps, step, output, maxiters);
    }
}

double testCorrect(unsigned *output, int size) {
    double error = 0.0;
    FILE* f = fopen("reference.out", "r");
    if(!f) {printf("Could not open reference.out\n"); return -1.0;}
    for(int i = 0; i < size; i++) {
        int ref;
        fscanf(f, "%i ", &ref);
        error += (double)abs((ref - output[i]))/((double)ref);
    }
    fclose(f);
    return error/((double)size);
}

void genReference(unsigned *output, int size) {
    FILE* f = fopen("reference.out", "w");
    for(int i = 0; i < size; i++) {
        fprintf(f, "%u ", output[i]);
    }
    fclose(f);
}

unsigned* boxFilter(unsigned * output, int size, int horSize) {
    int newSize = size-1;
    int newHorSize = horSize-1;
    int numPix = (newSize)*(newHorSize);
    unsigned * filter = (unsigned*)malloc(numPix*sizeof(unsigned));
    #pragma omp parallel for
    for(int i = 0; i < newSize; i++) {
        for(int j = 0; j < newHorSize; j++) {
            unsigned sum = output[i*horSize+j] + output[i*horSize+j+1] 
                            + output[(i+1)*horSize+j] + output[(i+1)*horSize+j+1];
            unsigned average = (sum+2)/4;
            filter[i*newHorSize+j] = average;
        }
    }
    free(output);
    return filter;
}

void serialDouble(double startReal, double startImag, int steps, int horizsteps, double step, unsigned* output, unsigned maxIters) {
 
    #pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j++) {
            double real = startReal + step*j;
            double imag = startImag - step*i;
            unsigned iters = 0;
            double z_real = 0.0, z_imag = 0.0, z_sum = 0.0;
            while (z_sum < 4.0f && iters < maxIters) {
                iters++;
                double z_real_sq = z_real*z_real;
                double z_imag_sq = z_imag*z_imag;
                z_sum = z_real_sq + z_imag_sq;
                z_imag = 2.0*z_real*z_imag + imag;
                z_real = z_real_sq - z_imag_sq + real;
            }
            output[i*horizsteps+j] = iters;
        }
    }
}

void serialFloat(float startReal, float startImag, int steps, int horizsteps, float step, unsigned* output, unsigned maxIters) {
    
    #pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j++) {
            float real = startReal + step*j;
            float imag = startImag - step*i;
            unsigned iters = 0;
            float z_real = 0.0f, z_imag = 0.0f, z_sum = 0.0f;
            while (z_sum < 4.0f && iters < maxIters) {
                iters++;
                float z_real_sq = z_real*z_real;
                float z_imag_sq = z_imag*z_imag;
                z_sum = z_real_sq + z_imag_sq;
                z_imag = 2.0f*z_real*z_imag + imag;
                z_real = z_real_sq - z_imag_sq + real;
            } 
            output[i*horizsteps+j] = iters;
        }
    }
}

#ifdef __SSE2__
void sse2Float(float startReal, float startImag, int steps, int horizsteps, float step, unsigned* output, signed maxiters) {
    
    /* unsigned integer comparisons not available in SSE2 */

    //#pragma omp parallel for
    #pragma omp parallel for schedule(guided)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j+=4) {
            __m128 reals = _mm_set1_ps(startReal + step*j);
            __m128 deltas = _mm_set_ps(0.0f, step, 2.0f*step, 3.0f*step);
            reals = _mm_add_ps(reals, deltas);
            __m128 imags = _mm_set1_ps(startImag - step*i);
            __m128i iters = _mm_setzero_si128();
            __m128i maxIters = _mm_set1_epi32(maxiters);
            __m128 z_reals = _mm_setzero_ps();
            __m128 z_imags = _mm_setzero_ps();
            __m128 z_sums = _mm_setzero_ps();
            __m128i cmp_val = _mm_set1_epi32(-1);
            __m128 fours = _mm_set1_ps(4.0f);
            __m128 twos = _mm_set1_ps(2.0f);
            __m128 negativeFours = _mm_set1_ps(-4.0f);
            while ( hor_m128i(cmp_val)  &&  !hor_m128i(_mm_cmpeq_epi32(iters, maxIters)) ) {
                /* iters++ */ iters = _mm_sub_epi32(iters, cmp_val);
                __m128 z_real_sq = _mm_mul_ps(z_reals, z_reals);
                __m128 z_imag_sq = _mm_mul_ps(z_imags, z_imags);
                z_sums = _mm_add_ps(z_real_sq, z_imag_sq);
                __m128i isLessThan4 = _mm_castps_si128(_mm_cmplt_ps(z_sums, fours));
                __m128i isGtrThanNeg4 = _mm_castps_si128(_mm_cmpgt_ps(z_sums, negativeFours));
                cmp_val = _mm_and_si128(isLessThan4, isGtrThanNeg4);
                z_imags = _mm_add_ps(_mm_mul_ps(_mm_mul_ps(twos, z_reals), z_imags), imags);
                z_reals = _mm_add_ps(_mm_sub_ps(z_real_sq, z_imag_sq), reals);
            }
            int startIndex = i*horizsteps+j;    
            output[startIndex++] = ((unsigned*)(&iters))[3];
            output[startIndex++] = ((unsigned*)(&iters))[2];
            output[startIndex++] = ((unsigned*)(&iters))[1];
            output[startIndex++] = ((unsigned*)(&iters))[0]; 
        }
    }
}
#endif

#ifdef __AVX__
void avxFloat(float startReal, float startImag, int steps, int horizsteps, float step, unsigned* output, unsigned maxiters) {

    float maxitersfloat = (float)maxiters;
    //#pragma omp parallel for
    #pragma omp parallel for schedule(dynamic)
    for (int i = 0; i < steps; i++) {
<<<<<<< HEAD
        #pragma omp parallel for schedule(guided)
=======
>>>>>>> 5c677317e64b2e96d1ffa09a6086a0af84c697d1
        for (int j = 0; j < horizsteps; j+=8) {
            __m256 reals = _mm256_set1_ps(startReal + step*j);
            __m256 deltas = _mm256_set_ps(0.0f, step, 2.0f*step, 3.0f*step, 4.0f*step, 5.0f*step, 6.0f*step, 7.0f*step);
            reals = _mm256_add_ps(reals, deltas);
            __m256 imags = _mm256_set1_ps(startImag - step*i);
            __m256 iters = _mm256_setzero_ps();
            __m256 maxIters = _mm256_set1_ps(maxitersfloat);
            __m256 z_reals = _mm256_setzero_ps();
            __m256 z_imags = _mm256_setzero_ps();
            __m256 z_sums = _mm256_setzero_ps();
            __m256 cmp_val = _mm256_castsi256_ps(_mm256_set1_epi32(-1));
            __m256 fours = _mm256_set1_ps(4.0f);
            __m256 twos = _mm256_set1_ps(2.0f);
            __m256 negativeFours = _mm256_set1_ps(-4.0f);
            while ( hor_m256(cmp_val)  &&  !hor_m256(_mm256_cmp_ps(iters, maxIters, _CMP_GE_OQ)) ) {
                // iters++ performed by using integer ops separately on the halves of iters
                __m128 itershalf0 = _mm256_extractf128_ps(iters, 0);  // half of iters
                __m128 itershalf1 = _mm256_extractf128_ps(iters, 1);  // other half
                __m128 cmpvalhalf0 = _mm256_extractf128_ps(cmp_val, 0);
                __m128 cmpvalhalf1 = _mm256_extractf128_ps(cmp_val, 1);
                itershalf0 = _mm_cvtepi32_ps(_mm_sub_epi32(_mm_cvtps_epi32(itershalf0), _mm_castps_si128(cmpvalhalf0)));
                itershalf1 = _mm_cvtepi32_ps(_mm_sub_epi32(_mm_cvtps_epi32(itershalf1), _mm_castps_si128(cmpvalhalf1)));
                iters = _mm256_insertf128_ps(iters, itershalf0, 0); // reassemble iters
                iters = _mm256_insertf128_ps(iters, itershalf1, 1);    
                __m256 z_real_sq = _mm256_mul_ps(z_reals, z_reals);
                __m256 z_imag_sq = _mm256_mul_ps(z_imags, z_imags);
                z_sums = _mm256_add_ps(z_real_sq, z_imag_sq);
                __m256 isLessThan4 = _mm256_cmp_ps(z_sums, fours, _CMP_LT_OQ);
                __m256 isGtrThanNeg4 = _mm256_cmp_ps(z_sums, negativeFours, _CMP_GT_OQ);
                cmp_val = _mm256_and_ps(isLessThan4, isGtrThanNeg4);
                z_imags = _mm256_add_ps(_mm256_mul_ps(_mm256_mul_ps(twos, z_reals), z_imags), imags);
                z_reals = _mm256_add_ps(_mm256_sub_ps(z_real_sq, z_imag_sq), reals);
            }
            int startIndex = i*horizsteps+j;    
            output[startIndex++] = (unsigned)( ((float*)(&iters))[7] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[6] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[5] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[4] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[3] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[2] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[1] );
            output[startIndex++] = (unsigned)( ((float*)(&iters))[0] ); 
        }
    }
}
#endif

#ifdef __MIC__
void phiFloat(float startReal, float startImag, int steps, int horizsteps, float step, unsigned* output, signed maxiters) {
    
    #pragma omp parallel for schedule(guided)
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < horizsteps; j+=16) {
            __m512 reals = _mm512_set1_ps(startReal + step*j);
            __m512 deltas = _mm512_setr_ps(0.0f, step, 2.0f*step, 3.0f*step, 4.0f*step, 5.0f*step, 6.0f*step, 7.0f*step, 8.0f*step, 9.0f*step, 10.0f*step, 11.0f*step, 12.0f*step, 13.0f*step, 14.0f*step, 15.0f*step);
            reals = _mm512_add_ps(reals, deltas);
            __m512 imags = _mm512_set1_ps(startImag - step*i);
            __m512i iters = _mm512_setzero_epi32();
            __m512i maxIters = _mm512_set1_epi32(maxiters);
            __m512 z_reals = _mm512_setzero_ps();
            __m512 z_imags = _mm512_setzero_ps();
            __m512 z_sums = _mm512_setzero_ps();
            __mmask16 cmp_val = _mm512_int2mask(-1);
            __m512 fours = _mm512_set1_ps(4.0f);
            __m512 twos = _mm512_set1_ps(2.0f);
            __m512i ones = _mm512_set1_epi32(1);
            __m512 negativeFours = _mm512_set1_ps(-4.0f);
            while ( (cmp_val)  &&  !(_mm512_cmpeq_epi32_mask(iters, maxIters)) ) {
                /* iters++ */ iters = _mm512_mask_add_epi32(iters, cmp_val, iters, ones);
                __m512 z_real_sq = _mm512_mul_ps(z_reals, z_reals);
                __m512 z_imag_sq = _mm512_mul_ps(z_imags, z_imags);
                z_sums = _mm512_add_ps(z_real_sq, z_imag_sq);
                __mmask16 isLessThan4 = _mm512_cmplt_ps_mask(z_sums, fours);
                // nle: not less than or equal (i.e. greater than)
                __mmask16 isGtrThanNeg4 = _mm512_cmpnle_ps_mask(z_sums, negativeFours);  
                cmp_val = _mm512_kand(isLessThan4, isGtrThanNeg4);
                z_imags = _mm512_fmadd_ps(_mm512_mul_ps(twos, z_reals), z_imags, imags);
                z_reals = _mm512_add_ps(_mm512_sub_ps(z_real_sq, z_imag_sq), reals);
            }
            int index = i*horizsteps+j;    
            // does not need reversing because we used setr not set
            for ( ; index < i*horizsteps+j + 16; index++ ) {
                output[index] = ((unsigned*)(&iters))[index];
            }
        }
    }
}
#endif

void printUsage() {
    printf("Usage: testHarness serial|SSE2|AVX|ISPC -c centerReal centerImag -s size -d steps -f filename -b\n");
}

int main(int argc, char* argv[]) {
    float centerReal = 0.0f, centerImag = 0.0f;
    float size = 4.0f;
    int steps = 864;
    char filename[50] = "mandelbrot.ppm";
    unsigned maxIters = 20050;
    bool bench = false;
    bool initRefData = false;

    if (argc < 2) {
      printUsage();
      return 0;
    }

    // parse serial|SSE2|AVX|ISPC
    bool serial = false;
    bool sse2 = false;
    bool avx = false;
    bool ispc = false;
    bool phi = false;
    if (!strcmp(argv[1], "serial\0")) serial = true;
    else if (!strcmp(argv[1], "SSE2\0")) sse2 = true;
    else if (!strcmp(argv[1], "AVX\0")) avx = true;
    else if (!strcmp(argv[1], "ISPC\0")) ispc = true;
    else if (!strcmp(argv[1], "Phi\0")) phi = true;
    else {
      printUsage();
      return 0;
    }

    int counter = 2;
    while ( counter < argc ) {
        if (!strcmp(argv[counter], "-c\0") && argc >= (counter + 3)) {
            sscanf(argv[++counter], "%f", &centerReal);
            sscanf(argv[++counter], "%f", &centerImag);
            counter++;
        } else if (!strcmp(argv[counter], "-s\0") && argc >= (counter + 2)) {
            sscanf(argv[++counter], "%f", &size);
            counter++;
        } else if (!strcmp(argv[counter], "-d\0") && argc >= (counter + 2)) {
            sscanf(argv[++counter], "%i", &steps);
            counter++;
        } else if (!strcmp(argv[counter], "-f\0") && argc >= (counter + 2)) {
            sscanf(argv[++counter], "%s", filename);
            counter++;
        } else if (!strcmp(argv[counter], "-b\0")) {
            bench = true;
            counter++;
        } else {
            printUsage();
            return 0;
        }
    }
    if(bench) {
        centerReal = -0.54f;
        centerImag = 0.5f;
        size = 0.1f;
        steps = 864;
        maxIters = 50000;
    }
    if (sse2)
        // make steps divisible by 4
        while (steps % 4 != 0) steps++;
    else if (avx)
        // make steps divisible by 8
        while (steps % 8 != 0) steps++;
    else if (phi)
        // make steps divisible by 16
        while (steps % 16 != 0) steps++;
    
    int horizsteps = steps*16/9;
    if (horizsteps % 16 != 0) {
        printf("Use one of these numbers of steps: 576, 864, 1152, 1440, 1728, 2304\n");
        printf("steps: %i, horizsteps: %i\n", steps, horizsteps);
        return 0;
    }

    int numPixels = steps*horizsteps;
    unsigned* output = (unsigned*)malloc(numPixels*sizeof(unsigned));
    
    float horizsize = size*16.0f/9.0f;

    wkf_timerhandle timer = wkf_timer_create();


    float startReal = centerReal - (horizsize/2.0f), startImag = centerImag + (size/2.0f);
    float stepsize = size/steps;
    float time;
    
    if(initRefData) {
        maxIters = 50000;
        serialFloat(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        output = boxFilter(output, steps, horizsteps);
        numPixels = (steps-1)*(horizsteps-1);
        genReference(output, numPixels);
        printf("At 5%% tolerance, the percent error was  %.3f%%.\n", 100.0*testCorrect(output, numPixels)); 
        return 0;
    }
    if (bench) {
        int warmUpRuns = 10;
        for (int i = 0; i < warmUpRuns; i++) {
            serialFloat(-2.0f, 2.0f, steps, horizsteps, 0.004f, output, 500);
        }
        printf("======================\n");
    }

    if (serial) {

        wkf_timer_start(timer); 
        serialFloat(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        wkf_timer_stop(timer);
        time = wkf_timer_time(timer);
        if(bench) printf("serialFloat: Time: %f\n", time);

    } else if (sse2) {
    
#ifdef __SSE2__
        wkf_timer_start(timer); 
        sse2Float(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        wkf_timer_stop(timer);
        time = wkf_timer_time(timer);
        if(bench) printf("sse2Float: Time: %f\n", time);
#endif

    } else if (avx) {
       
#ifdef __AVX__
        wkf_timer_start(timer);
        avxFloat(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        wkf_timer_stop(timer);
        time = wkf_timer_time(timer);
        if(bench) printf("avxFloat: Time: %f\n", time);
#endif
       
    } else if (phi) {

#ifdef __MIC__
        wkf_timer_start(timer);
        phiFloat(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        wkf_timer_stop(timer);
        time = wkf_timer_time(timer);
        if(bench) printf("phiFloat: Time: %f\n", time);
#endif
   
    } else if (ispc) {

        wkf_timer_start(timer);
        ispcOMP(startReal, startImag, steps, horizsteps, stepsize, output, maxIters);
        wkf_timer_stop(timer);
        time = wkf_timer_time(timer);
        if(bench) printf("ispcFloat: Time: %f\n", time);

    }

    output = boxFilter(output, steps--, horizsteps--);
    int oldNumPixels = numPixels;
    numPixels = steps*horizsteps;
    // performance metrics
    if (bench) {
        uint64_t sum = 0;
        #pragma omp parallel for reduction(+:sum)
        for (int i = 0; i < numPixels; i++) {
            unsigned iters = output[i];
            sum += iters;
        }
        printf("Iters per second: %f\nGFLOPS: %f\nIters per pixel per second: %f\n", sum/time, sum/time*8/1000000000, (sum/oldNumPixels)/time);
    } 
    if (bench) {
        double error = testCorrect(output, numPixels);
        if (error < 0) { printf("Aborting.\n"); return 0; }  // testCorrect failed to find the reference file
        printf("The percent error was %.3f%%. ", 100.0*error);
        if(error < 0.05) {
            printf("Error within acceptable region.\n");
        } else {
            printf("Error outside acceptable region. Aborting.\n");
            return 0;
        }
        printf("======================\n");
    }

    #define ITERS_CYCLE 100
    #define COLORMIN 0
    #define COLORMAX 220

    // write picture data
    FILE* f = fopen(filename, "w");
    if (!f) { printf("Error opening file\n"); return(0); }
    fprintf(f, "P6\n%i %i\n255\n", horizsteps, steps);    
    unsigned char* buffer = (unsigned char*)malloc(3*numPixels*sizeof(unsigned char));
    #pragma omp parallel for 
    for (int i = 0; i < numPixels; i++) {
        int itersForColor = (maxIters-output[i]) % (ITERS_CYCLE*4);
        char red, green, blue;
        switch(itersForColor/ITERS_CYCLE) {
            case 0: // black to green region
                red = COLORMIN;
                green = COLORMIN + (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                blue = COLORMIN;
                break;               
            case 1: // green to red region
                itersForColor -= ITERS_CYCLE;
                red = COLORMIN + (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                green = COLORMAX - (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                blue = COLORMIN;
                break;
            case 2: // red to blue region
                itersForColor -= (2*ITERS_CYCLE);
                red = COLORMAX - (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                green = COLORMIN;
                blue = COLORMIN + (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                break;
            case 3: // blue to black region
                itersForColor -= (3*ITERS_CYCLE);
                red = COLORMIN; 
                green = COLORMIN;
                blue = COLORMAX - (itersForColor*(COLORMAX-COLORMIN))/ITERS_CYCLE;
                break;
            default: // should never happen
                printf("Error in color mapping\n");
                break;
        }
        int bufferIndex = i*3;
        buffer[bufferIndex++] = red;
        buffer[bufferIndex++] = green;
        buffer[bufferIndex] = blue;
    }
     
    fwrite(buffer, sizeof(unsigned char), 3*numPixels, f);

    fclose(f);

    return 0;
}

